#include "../UTIL.SISA"

init:
    CLIR, sp, STACK_START; // incializar stack pointer
    
start:
    // key expansion

    CLIR, arg0, ENC_HDR_AES_KEY;
    
    CLIR, t0, 0xCDEF;
    CLIR, t1, 0x89AB;
    SLLI, t1, t1, 16;
    CLIR, t2, 0x4567;
    CLIR, t3, 0x0123;
    SLLI, t3, t3, 16;
    OR, t0, t0, t1;
    OR, t2, t2, t3;
    STM, t0, arg0, 0;
    STM, t2, arg0, 4;
    STM, t0, arg0, 8;
    STM, t2, arg0, 12;
    
    call, key_expansion;

    //LDM, t0, zero, ENC_HDR_OP; // se puede porque imm es de 15 bits, signo extendido
    CLIR, t2, UART_BASE;
    //JINE, t0, zero, decrypt;
    //JMP, encrypt;
    JMP, decrypt;
    
encrypt:   
    CLIR, t3, 'E';
    STM, t3, t2, 0;
    CLIR, arg0, RAM_BASE;

    CLIR, g6, 0;
    CLIR, g7, 42; // cambiar por n bloques
    encrypt_loop:
        call, encrypt_block; // falta ciclo de bloques
        SUMI, arg0, arg0, 16; // moverse a siguiente bloque 
        SUMI, g6, g6, 1;
        JILT, g6, g7, encrypt_loop;
    
    JMP, end;

/* Ejecuta la expansion de llaves
args:
    - arg0 puntero al bloque a encriptar
ret:
    - arg0 puntero a bloque encriptado
*/
encrypt_block:
    PUSH(lr)
    //PUSH(g0)
    //PUSH(g1)
    //PUSH(g2)
    CLIR, g0, ENC_HDR_AES_KEY; // puntero al key store
    // arg0 ya tiene el puntero a datos
    // add roundkey 0
    MOV(arg1, g0);
    call, add_roundkey;


    CLIR, g1, 1; // indice loop
    CLIR, g2, 10; //max iter LT
    encrypt_block_loop:
        // aumentar puntero roundkey 
        SUMI, g0, g0, 16;
        // subytes
        CLIR, arg1, SBOX_BASE;
        call, subbytes;
        // shift rows 
        call, shift_rows;
        // mix columns
        call, mix_columns;
        // add roundkey
        MOV(arg1, g0);
        call, add_roundkey;


        SUMI, g1, g1, 1;
        JILT, g1, g2, encrypt_block_loop;
    
    // ronda final
    // aumentar puntero de roundkey
    SUMI, g0, g0, 16;
    // subbytes
    CLIR, arg1, SBOX_BASE;
    call, subbytes;
    // shift rows
    call, shift_rows;
    // add roundkey final
    MOV(arg1, g0);
    call, add_roundkey;
    //POP(g2)
    //POP(g1)
    //POP(g0)
    POP(lr)
    JBA;

decrypt:   
    CLIR, t3, 'D';
    STM, t3, t2, 0;
    CLIR, arg0, RAM_BASE;

    CLIR, g6, 0;
    CLIR, g7, 42; // cambiar por n bloques
    decrypt_loop:
        call, decrypt_block; // falta ciclo de bloques
        SUMI, arg0, arg0, 16; // moverse a siguiente bloque 
        SUMI, g6, g6, 1;
        JILT, g6, g7, decrypt_loop;
    
    NOP;
    NOP;
    NOP; // me estresa la simul
    NOP; // me estresa la simul
    NOP; // me estresa la simul
    NOP; // me estresa la simul
    JMP, end;

/* Ejecuta la desencriptación
args:
    - arg0 puntero al bloque a encriptar
ret:
    - arg0 puntero a bloque encriptado
*/
decrypt_block:
    PUSH(lr)
    //PUSH(g0)
    //PUSH(g1)
    //PUSH(g2)
    CLIR, g0, ENC_HDR_AES_KEY; // puntero al key store
    SUMI, g0, g0, 160; // apuntar a última llave
    // arg0 ya tiene el puntero a datos
    // add roundkey 0
    MOV(arg1, g0);
    call, add_roundkey;


    CLIR, g1, 1; // indice loop
    CLIR, g2, 10; //max iter LT
    decrypt_block_loop:
        // aumentar puntero roundkey 
        DIFI, g0, g0, 16;
        // shift rows 
        call, inv_shift_rows;
        // subytes
        CLIR, arg1, RSBOX_BASE;
        call, subbytes;
        // add roundkey
        MOV(arg1, g0);
        call, add_roundkey;
        // mix columns
        call, inv_mix_columns;


        SUMI, g1, g1, 1;
        JILT, g1, g2, decrypt_block_loop;
    

    // ronda final
    // decrementar puntero de roundkey
    DIFI, g0, g0, 16;
    // shift rows
    call, inv_shift_rows;
    // subbytes
    CLIR, arg1, RSBOX_BASE;
    call, subbytes;
    // add roundkey final
    MOV(arg1, g0);
    call, add_roundkey;
    //POP(g2)
    //POP(g1)
    //POP(g0)
    POP(lr)
    JBA;


end:
   END_SIMUL;
   JMP, end;

#include "aux.SISA" //incluir acá porque si no se procesa primero