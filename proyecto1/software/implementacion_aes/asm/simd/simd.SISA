#include "../UTIL.SISA"

init:
    CLIR, sp, STACK_START; // incializar stack pointer
    
start:
    // key expansion

    CLIR, arg0, ENC_HDR_AES_KEY;
    
    CLIR, t0, 0xCDEF;
    CLIR, t1, 0x89AB;
    SLLI, t1, t1, 16;
    CLIR, t2, 0x4567;
    CLIR, t3, 0x0123;
    SLLI, t3, t3, 16;
    OR, t0, t0, t1;
    OR, t2, t2, t3;
    STM, t0, arg0, 0;
    STM, t2, arg0, 4;
    STM, t0, arg0, 8;
    STM, t2, arg0, 12;
    // pruebas para ver comportamiento de load hazard
    /*LDM, t0, arg0, 0;
    LDM, t1, arg0,4;
    XOR, t0, t0, t1;
    LDV, v0, arg0, 0;
    LDV, v1, arg0, 4;
    VXOR, v0, v0, v1;
    END_SIMUL;*/
    
    CALL, key_expansion;

    //LDM, t0, zero, ENC_HDR_OP; // se puede porque imm es de 15 bits, signo extendido
    CLIR, t2, UART_BASE;
    //JINE, t0, zero, decrypt;
    JMP, decrypt;
   
encrypt:   
    CLIR, t3, 'E';
    STM, t3, t2, 0;
    CLIR, arg0, RAM_BASE;

    CLIR, g0, 0;
    CLIR, g1, 32;
    encrypt_loop:
        CALL, encrypt_block; // falta ciclo de bloques
        SUMI, arg0, arg0, 16; // moverse a siguiente bloque 
        SUMI, g0, g0, 1;
        JILT, g0, g1, encrypt_loop;
    
    JMP, end;

/* Ejecuta la expansion de llaves
args:
    - arg0 puntero al bloque a encriptar
ret:
    - arg0 puntero a bloque encriptado
*/
encrypt_block:
    CLIR, t0, ENC_HDR_AES_KEY; // puntero al key store

    LDV, v0, arg0, 0; // cargar estado
    LDV, v1, t0, 0; // cargar round_key
    VXOR, v0, v0, v1; // add roundkey

    CLIR, t1, 1; // indice loop
    CLIR, t2, 10; //max iter LT
    encrypt_block_loop:
        SUMI, t0, t0, 16; // aumentar puntero de roundkey
        LDV, v1, t0, 0; // cargar roundkey para esta ronda
        VAES_SUB, v0, v0, zero; //sub bytes
        VAES_SHIFT, v0, v0, zero; // shift rows 
        VAES_MIX, v0, v0, zero; // mix colums en inmediatamente add roundkey
        VXOR, v0, v0, v1;

        SUMI, t1, t1, 1;
        JILT, t1, t2, encrypt_block_loop;
    
    // ronda final
    SUMI, t0, t0, 16; // aumentar puntero de roundkey
    LDV, v1, t0, 0; // cargar roundkey para esta ronda
    VAES_SUB, v0, v0, zero; //sub bytes
    VAES_SHIFT, v0, v0, zero; // shift rows y add roundkey final
    VXOR, v0, v0, v1; // shift rows y add roundkey final
    STV, v0, arg0, 0;
    JBA;

decrypt:   
    CLIR, t3, 'D';
    STM, t3, t2, 0;
    CLIR, arg0, RAM_BASE;

    CLIR, g0, 0;
    CLIR, g1, 32;
    decrypt_loop:
        CALL, decrypt_block; // falta ciclo de bloques
        SUMI, arg0, arg0, 16; // moverse a siguiente bloque 
        SUMI, g0, g0, 1;
        JILT, g0, g1, decrypt_loop;
    
    JMP, end;

/* Ejecuta la expansion de llaves
args:
    - arg0 puntero al bloque a encriptar
ret:
    - arg0 puntero a bloque encriptado
*/
decrypt_block:
    CLIR, t0, ENC_HDR_AES_KEY; // puntero al key store
    SUMI, t0, t0, 160; // apuntar a última llave

    LDV, v0, arg0, 0; // cargar estado
    LDV, v1, t0, 0; // cargar round_key
    VXOR, v0, v0, v1; // add roundkey

    CLIR, t1, 1; // indice loop
    CLIR, t2, 10; //max iter LT
    decrypt_block_loop:
        DIFI, t0, t0, 16; // decrementar puntero de roundkey
        LDV, v1, t0, 0; // cargar roundkey para esta ronda
        VAES_ISHIFT, v0, v0, zero; // shift rows 
        VAES_ISUB, v0, v0, zero; //sub bytes
        VXOR, v0, v0, v1; // add roundkey
        VAES_IMIX, v0, v0, zero; // mix colums en inmediatamente add roundkey

        SUMI, t1, t1, 1;
        JILT, t1, t2, decrypt_block_loop;
    
    // ronda final
    DIFI, t0, t0, 16; // decrementar puntero de roundkey
    LDV, v1, t0, 0; // cargar roundkey para esta ronda
    VAES_ISHIFT, v0, v0, zero; // shift rows y add roundkey final
    VAES_ISUB, v0, v0, zero; //sub bytes
    VXOR, v0, v0, v1; //add roundkey final
    STV, v0, arg0, 0;
    JBA;


end:
   END_SIMUL;
   JMP, end;


/* Obtiene el valor de rcon para una ronda
args: 
    - arg0: # de ronda de key expansion empieza en 0
ret:
    - arg0: valor de rcon
*/
get_rcon:
    CLIR, t0, 0x01; // valor rcon ronda 0
    CLIR, t1, 0x100; // valor que se debe reemplazar por 1B
    CLIR, t2, 0x1B;
    SLL, arg0, t0, arg0;
    JILT, arg0, t1, get_rcon_end;
    get_rcon_gt_0x100:
        // Obtener cuantos shifts a la izquierda se necesitan
        SLRI, t3, arg0, 9;
        SLL, arg0, t2, t3; // 0x1B << t3
    get_rcon_end:
        JBA;

/* Ejecuta la expansion de llaves
args:
    - arg0 dirección del key store, con la primera llave ya cargada
ret:
    - arg0 valor inicial
*/
key_expansion:
    PUSH(lr)
    PUSH(arg0)
    PUSH(g0)
    PUSH(g1)
    PUSH(g2)
    
    CLIR, g0, 0; // indice de llave generada
    CLIR, g1, 10; // max indice
    MOV(g2, arg0); // puntero al key store

    key_expansion_loop:
        LDV, v0, g2, 0;// cargar llave anterior 
        LDM, v1, g2, 12; // cargar w3 en las 4 palabras de v1 
        
        CLIR, t4, 8; // interpret vectorial es 8 en todas las palabras
        VROT32, v1, v1, t4; // rotword 8 bits a la derecha
        VAES_SUB, v1, v1, zero; // subword
        // obtener rcon 
        MOV(arg0, g0);
        CALL, get_rcon; // rcon está en arg0
        VXOR, v1, v1, arg0; // aplicar rcon
        VAES_WXOR, v2, v0, v1; // generar llave de próxima ronda 
        
        SUMI, g2, g2, 16; // aumentar puntero de llave
        STV, v2, g2, 0; // guardar nueva llave

        SUMI, g0, g0, 1;
        JILT, g0, g1, key_expansion_loop; 


    POP(g2)
    POP(g1)
    POP(g0)
    POP(arg0)
    POP(lr)
    JBA;
